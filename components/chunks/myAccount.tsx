/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useEffect, useRef, useState } from 'react'
import { ethers } from 'ethers'
import { create as IPFSHTTPClient } from 'ipfs-http-client'
import useRouter from 'next/router'
import Web3Modal from 'web3modal'
import { Html, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

import { nftAddress, nftMarketAddress } from '@/nftConfig'

import NFT from '@/artifacts/contracts/NFT.sol/NFT.json'
import Market from '@/artifacts/contracts/NFTMarket.sol/NFTMarket.json'
import axios from 'axios'
import { Camera } from '@react-three/fiber'
import DropModel from '@/components/chunks/shared/dropModel'
import NFTComp from '@/components/nft'
import useCharacter from '@/store/character'
import useCreateNFT from '@/store/huds/createNFT'
import useHUD from '@/store/huds/main'

const client = IPFSHTTPClient({
  apiPath: '/api/v0',
  host: 'ipfs.infura.io',
  port: 5001,
  protocol: 'https',
})

type GLTFResult = GLTF & {
  nodes: {
    ['voxel_map_level1-4-0_1']: THREE.Mesh
    ['voxel_map_level1-4-0_2']: THREE.Mesh
    ['voxel_map_level1-4-0_3']: THREE.Mesh
    ['voxel_map_level1-4-0_4']: THREE.Mesh
    ['voxel_map_level1-4-0_5']: THREE.Mesh
    ['voxel_map_level1-4-0_6']: THREE.Mesh
    ['voxel_map_level1-4-0_7']: THREE.Mesh
    ['voxel_map_level1-4-0_8']: THREE.Mesh
    ['show-model']: THREE.Mesh
    ['model-placeholder-1']: THREE.Mesh
    ['model-placeholder-2']: THREE.Mesh
    ['model-placeholder-3']: THREE.Mesh
    ['model-placeholder-4']: THREE.Mesh
  }
  materials: {
    ['floor-wall']: THREE.MeshBasicMaterial
    ['drop-box']: THREE.MeshBasicMaterial
    ['auth-box']: THREE.MeshBasicMaterial
    ['box-base-grey']: THREE.MeshBasicMaterial
    ['box-base-orange']: THREE.MeshBasicMaterial
    box: THREE.MeshBasicMaterial
    ['auth-button']: THREE.MeshBasicMaterial
    ['auth-text']: THREE.MeshBasicMaterial
  }
}

export default function Model({ ...props }: JSX.IntrinsicElements['group']) {
  const group = useRef<THREE.Group>()
  const dropBoxRef = useRef<THREE.Mesh>()
  const { setCanMove } = useCharacter(({ setCanMove }) => ({ setCanMove }))
  const { setCurrentHud, setShowHud } = useHUD(
    ({ setCurrentHud, setShowHud }) => ({ setCurrentHud, setShowHud })
  )

  const { nodes, materials } = useGLTF(
    'models/level3-placeholders.glb'
  ) as GLTFResult

  const [fileUrl, setFileUrl] = useState<string>('')

  const { formInput, isSubmitted, setSubmitted } = useCreateNFT(
    ({ formInput, setSubmitted, isSubmitted }) => ({
      formInput,
      setSubmitted,
      isSubmitted,
    })
  )

  const createSale = async (url) => {
    const web3modal = new Web3Modal()
    const connection = await web3modal.connect()
    const provider = new ethers.providers.Web3Provider(connection)
    const signer = provider.getSigner()

    console.log(url, nftAddress)
    let contract = new ethers.Contract(nftAddress, NFT.abi, signer)
    let transaction = await contract.createToken(url)
    let tx = await transaction.wait()
    console.log(tx)

    let event = tx.events[0]
    let value = event.args[2]
    let tokenId = value.toNumber()

    const price = ethers.utils.parseUnits(formInput.price, 'ether')

    // added this NFT on marketplace
    contract = new ethers.Contract(nftMarketAddress, Market.abi, signer)
    let listingPrice = await contract.getListingPrice()
    listingPrice = listingPrice.toString()

    transaction = await contract.createMarketItem(nftAddress, tokenId, price, {
      value: listingPrice,
    })
    await transaction.wait()
  }

  const createNFT = async () => {
    const { price, name, description } = formInput
    if (!price || !name || !description) return

    console.log('saving file url:', fileUrl)
    const data = JSON.stringify({
      name,
      description,
      image: fileUrl,
    })

    console.log('data:', data, price, name, description)

    try {
      const added = await client.add(data)
      const url = `https://ipfs.infura.io/ipfs/${added.path}`

      await createSale(url)
    } catch (err) {
      console.log(`Error uploading file: ${err}`)
    }
  }

  // creating NFT if form is submitted
  useEffect(() => {
    if (isSubmitted) {
      console.log('submitted')
      createNFT()
      setSubmitted(false)
    }
  }, [isSubmitted])

  const [nfts, setNfts] = useState([])
  const [sold, setSold] = useState([])
  const [loadingState, setLoadingState] = useState('not-loaded')

  useEffect(() => {
    loadNFTs()
  }, [])

  async function loadNFTs() {
    const web3Modal = new Web3Modal()

    const connection = await web3Modal.connect()
    const provider = new ethers.providers.Web3Provider(connection)
    const signer = provider.getSigner()

    const marketContract = new ethers.Contract(
      nftMarketAddress,
      Market.abi,
      signer
    )
    const tokenContract = new ethers.Contract(nftAddress, NFT.abi, provider)
    const data = await marketContract.fetchItemsCreated()

    const items = await Promise.all(
      data.map(async (i) => {
        const tokenUri = await tokenContract.tokenURI(i.tokenId)

        // console.log(tokenUri)
        const meta = await axios.get(tokenUri).catch((err) => {
          // console.log('get model axios err', err)
        })

        // console.log(meta)

        let price = ethers.utils.formatUnits(i.price.toString(), 'ether')

        let item = {
          price,
          tokenId: i.tokenId.toNumber(),
          seller: i.seller,
          owner: i.owner,
          sold: i.sold,
          image: meta?.data?.image,
        }

        return item
      })
    )

    // filtering NFts with no image
    const filteredItems = items.filter((i) => i.image)
    console.log(filteredItems)

    /* create a filtered array of items that have been sold */
    const soldItems = filteredItems.filter((i) => i.sold)
    setSold(soldItems)
    setNfts(filteredItems)
    setLoadingState('loaded')
  }

  const onModelDrop = async (e) => {
    e.preventDefault()
    e.stopPropagation()

    const files = e.dataTransfer.files
    console.log('files', files)

    const model = files[0]

    try {
      if (model) {
        const uploadedModel = await client.add(model, {
          progress: (num) => console.log(`uploaded: ${num}`),
        })

        const url = `https://ipfs.infura.io/ipfs/${uploadedModel.path}`
        console.log('uploaded file url:', url)

        setFileUrl(url)
      }

      setCurrentHud('createNFT')
      setShowHud(true)
    } catch (err) {
      console.log(`Error uploading file: ${err}`)
    }
  }

  useEffect(() => {
    if (!window) return

    // window.addEventListener('drop', onModelDrop)

    return () => {
      // window.removeEventListener('drop', onModelDrop)
    }
  }, [])

  const modelPlaceholdersPosition = [
    [-53.31, 27.86, -55.63],
    [-17.48, 27.86, -55.63],
    [17.12, 27.86, -55.68],
    [51.93, 27.86, -55.51],
  ]

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      name='world'
      position={[300, 0, 80]}
      rotation={[0, 4.4, 0]}
    >
      <mesh
        geometry={nodes['voxel_map_level1-4-0_1'].geometry}
        material={materials['floor-wall']}
      />
      <mesh
        ref={dropBoxRef}
        geometry={nodes['voxel_map_level1-4-0_2'].geometry}
        material={materials['drop-box']}
        // material-opacity={0}
        // material-depthWrite={false}
        // material-transparent={true}
        // onDrop
      >
        <Html
          as='div'
          prepend
          center
          fullscreen
          distanceFactor={10}
          zIndexRange={[100, 0]}
          transform
          onOcclude={(visible) => null}
          translateX={-100}
          scale={[6, 6, 6]}
          rotation={[1.57, 0, 0]}
        >
          <div
            style={{ width: '100px', height: '100px', backgroundColor: '#fff' }}
            onDragEnter={(e) => {
              console.log('drag enter', e)
            }}
            onDragOver={(e) => {
              e.preventDefault()
              e.stopPropagation()

              console.log('canvas drag over', e)
            }}
            onDrop={onModelDrop}
          ></div>
        </Html>
      </mesh>
      <mesh
        geometry={nodes['voxel_map_level1-4-0_3'].geometry}
        material={materials['auth-box']}
      />
      <mesh
        geometry={nodes['voxel_map_level1-4-0_4'].geometry}
        material={materials['box-base-grey']}
      />
      <mesh
        geometry={nodes['voxel_map_level1-4-0_5'].geometry}
        material={materials['box-base-orange']}
      />
      <mesh
        geometry={nodes['voxel_map_level1-4-0_6'].geometry}
        material={materials.box}
      />
      <mesh
        geometry={nodes['voxel_map_level1-4-0_7'].geometry}
        material={materials['auth-button']}
        onPointerDown={() => {
          console.log('auth button clicked')

          setCanMove(false)
        }}
        onPointerUp={() => {
          setCanMove(true)
        }}
      />
      <mesh
        geometry={nodes['voxel_map_level1-4-0_8'].geometry}
        material={materials['auth-text']}
      />
      {fileUrl ? (
        <DropModel fileUrl={fileUrl} />
      ) : (
        <mesh
          geometry={nodes['show-model'].geometry}
          material={nodes['show-model'].material}
          material-opacity={0}
          material-transparent={true}
          position={[-2.12, 31.64, 7.34]}
          scale={13.35}
        />
      )}
      {loadingState === 'loaded' && nfts
        ? nfts.map((el, i) => {
            return (
              <NFTComp
                position={modelPlaceholdersPosition[i]}
                key={i}
                {...el}
                onClick={() => {
                  console.log('clicked', el)
                }}
              />
            )
          })
        : null}
    </group>
  )
}

// useGLTF.preload('models/level3.glb')
