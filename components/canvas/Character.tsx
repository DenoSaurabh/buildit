/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useState, useRef, useEffect } from 'react'
import * as THREE from 'three'
import { useCamera, useGLTF } from '@react-three/drei'
import {
  MeshProps,
  RaycasterProps,
  useFrame,
  useThree,
} from '@react-three/fiber'
import useMouseDegreeOnDrag from '@/hooks/useMouseDegreeOnDrag'
import { GLTF } from 'three-stdlib'
import useCharacter from '@/store/character'
import detectLeftButtonBtn from '@/utils/detectLeftMouseBtn'

type GLTFResult = GLTF & {
  nodes: {
    character_1: THREE.Mesh
    character_2: THREE.Mesh
  }
  materials: {
    ['character #60']: THREE.MeshBasicMaterial
    ['character #73']: THREE.MeshBasicMaterial
  }
}

export default function Character({
  ...props
}: JSX.IntrinsicElements['group']) {
  const chracRef = useRef<MeshProps>()

  const aheadRaycastRef = useRef<RaycasterProps>()
  const downRaycastRef = useRef<RaycasterProps>()
  // const pointerRaycastRef = useRef()

  const { nodes, materials } = useGLTF('models/character.glb') as GLTFResult

  const [collides, setCollides] = useState([])

  const mouseDeg = useMouseDegreeOnDrag()
  // console.log(mouseDeg, 'mouse')

  const { setPosition, canMove } = useCharacter(({ setPosition, canMove }) => ({
    setPosition,
    canMove,
  }))

  const [moveForward, setMoveForward] = useState(false)

  useFrame(({ gl, scene, camera }) => {
    const objs = scene.getObjectByName('world')?.children

    if (chracRef.current) {
      chracRef.current.rotation.set(0, mouseDeg - 1, 0)

      let collidesData = []

      if (aheadRaycastRef.current && objs) {
        const intersectsAhead = aheadRaycastRef.current.intersectObjects(
          objs,
          true
        )

        if (intersectsAhead.length) {
          const closestBase = intersectsAhead.reduce((fir, sec) => {
            return fir.distance < sec.distance ? fir : sec
          }, [])

          if (closestBase.distance < 1) {
            setCollides([...collides, 'left'])
            collidesData = [...collides, 'ahead']
          } else {
            const removedCollides = collides.filter((el) => el !== 'left')

            setCollides(removedCollides)
            collidesData = removedCollides
          }
        }
      }

      if (moveForward && canMove) {
        if (collidesData.length > 0) return
        chracRef.current.translateX(-0.5) //-0.15
      }

      const currentCameraPos = camera.position.clone()
      const newCameraPos = new THREE.Vector3(
        100 + chracRef.current.position.x,
        100 + chracRef.current.position.y,
        -100 + chracRef.current.position.z
      )

      camera.position.lerpVectors(currentCameraPos, newCameraPos, 0.9)

      // setPosition([
      //   chracRef.current.position.x,
      //   chracRef.current.position.y,
      //   chracRef.current.position.z,
      // ])
    }

    if (downRaycastRef.current && objs) {
      const intersectsDown = downRaycastRef.current.intersectObjects(objs, true)

      if (intersectsDown.length) {
        const closestBase = intersectsDown.reduce((fir, sec) => {
          return fir.distance < sec.distance ? fir : sec
        })

        chracRef.current.position.y -= closestBase.distance - 3.5
      }
    }

    setPosition([
      chracRef.current.position.x,
      chracRef.current.position.y,
      chracRef.current.position.z,
    ])
  })

  const onMouseDown = (e) => {
    detectLeftButtonBtn(e) && setMoveForward(true)
  }

  const onMouseUp = (e) => {
    setMoveForward(false)
  }

  useEffect(() => {
    window.addEventListener('mousedown', onMouseDown)
    window.addEventListener('mouseup', onMouseUp)

    return () => {
      window.removeEventListener('mousedown', onMouseDown)
      window.removeEventListener('mouseup', onMouseUp)
    }
  }, [])

  return (
    <>
      <group
        ref={chracRef}
        {...props}
        dispose={null}
        userData={{ id: 'character' }}
        position={[0, 10, 0]}
      >
        <group scale={0.9}>
          <mesh
            geometry={nodes.character_1.geometry}
            material={materials['character #60']}
            userData={{ id: 'character_model' }}
          />
          <mesh
            geometry={nodes.character_2.geometry}
            material={materials['character #73']}
            userData={{ id: 'character_model' }}
          />
        </group>
      </group>

      {chracRef.current && (
        <group>
          <arrowHelper
            args={[
              new THREE.Vector3(1, 0, 0)
                .applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseDeg - 4.2)
                .normalize(),
              chracRef.current.getWorldPosition(chracRef.current.position),
              100,
              0xffff00,
            ]}
          />
          <raycaster
            args={[
              chracRef.current.getWorldPosition(chracRef.current.position),
              // new THREE.Vector3(
              //   -100,
              //   chracRef.current.position.y - 1,
              //   chracRef.current.position.z
              // ).normalize(),
              // chracRef.current.getWorldDirection(chracRef.current.rotation),
              // .normalize(),
              // chracRef.current.rotation.normalize(),
              new THREE.Vector3(1, 0, 0)
                .applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseDeg - 4.2)
                .normalize(),
            ]}
            ref={aheadRaycastRef}
            id='character-ahead-ray'
            userData={{ id: 'character-ahead-ray' }}
          />

          <raycaster
            args={[
              chracRef.current.getWorldPosition(chracRef.current.position),
              new THREE.Vector3(0, -100, 0).normalize(),
            ]}
            ref={downRaycastRef}
            id='character-down-ray'
            userData={{ id: 'character-down-ray' }}
          />
        </group>
      )}
    </>
  )
}

// useGLTF.preload('/character.glb')
