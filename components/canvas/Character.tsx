/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useState, useRef, useEffect } from 'react'
import * as THREE from 'three'
import {
  Html,
  useAnimations,
  useBVH,
  useGLTF,
  useHelper,
} from '@react-three/drei'
import {
  MeshProps,
  RaycasterProps,
  useFrame,
  useThree,
} from '@react-three/fiber'
import { GLTF } from 'three-stdlib'
import useCharacter from '@/store/character'
import detectLeftButtonBtn from '@/utils/detectLeftMouseBtn'

// import {
//   computeBoundsTree,
//   disposeBoundsTree,
//   acceleratedRaycast,
//   MeshBVHVisualizer,
// } from 'three-mesh-bvh'
import CollisionSystem from './collisionSystem'
import { styled } from '@/stitches.config'
import { chunkIndex, chunksData } from '@/utils/chunksLoad'
import respawnEvent from '@/events/respawn'
import { useRouter } from 'next/router'
import PlayerName from './playerName'

// Add the extension functions
// THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree
// THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree
// THREE.Mesh.prototype.raycast = acceleratedRaycast

// type GLTFResult = GLTF & {
//   nodes: {
//     character_1: THREE.Mesh
//     character_2: THREE.Mesh
//   }
//   materials: {
//     ['character #60']: THREE.MeshBasicMaterial
//     ['character #73']: THREE.MeshBasicMaterial
//   }
// }

type GLTFResult = GLTF & {
  nodes: {
    ['character_3_export-0']: THREE.Mesh
    ['character_3_export-0_1']: THREE.Mesh
    ['character_3_export-0_2']: THREE.Mesh
    ['character_3_export-0_3']: THREE.Mesh
    ['character_3_export-1']: THREE.Mesh
    ['character_3_export-1_1']: THREE.Mesh
    ['character_3_export-1_2']: THREE.Mesh
    ['character_3_export-1_3']: THREE.Mesh
    ['character_3_export-1_4']: THREE.Mesh
    ['character_3_export-1_5']: THREE.Mesh
    ['character_3_export-5']: THREE.Mesh
    ['character_3_export-5_1']: THREE.Mesh
    ['character_3_export-3']: THREE.Mesh
    ['character_3_export-3_1']: THREE.Mesh
    ['character_3_export-3_2']: THREE.Mesh
    ['character_3_export-4']: THREE.Mesh
    ['character_3_export-4_1']: THREE.Mesh
    ['character_3_export-2']: THREE.Mesh
    ['character_3_export-2_1']: THREE.Mesh
    ['character_3_export-2_2']: THREE.Mesh
  }
  materials: {
    ['character_3_export-0 #220']: THREE.MeshStandardMaterial
    ['character_3_export-0 #229']: THREE.MeshStandardMaterial
    ['character_3_export-0 #225']: THREE.MeshStandardMaterial
    ['character_3_export-0 #228']: THREE.MeshStandardMaterial
    ['character_3_export-1 #229']: THREE.MeshStandardMaterial
    ['character_3_export-1 #231']: THREE.MeshStandardMaterial
    ['character_3_export-1 #219']: THREE.MeshStandardMaterial
    ['character_3_export-1 #232']: THREE.MeshStandardMaterial
    ['character_3_export-1 #221']: THREE.MeshStandardMaterial
    ['character_3_export-1 #220']: THREE.MeshStandardMaterial
    ['character_3_export-5 #229']: THREE.MeshStandardMaterial
    ['character_3_export-5 #217']: THREE.MeshStandardMaterial
    ['character_3_export-3 #217']: THREE.MeshStandardMaterial
    ['character_3_export-3 #229']: THREE.MeshStandardMaterial
    ['character_3_export-3 #219']: THREE.MeshStandardMaterial
    ['character_3_export-4 #229']: THREE.MeshStandardMaterial
    ['character_3_export-4 #217']: THREE.MeshStandardMaterial
    ['character_3_export-2 #217']: THREE.MeshStandardMaterial
    ['character_3_export-2 #229']: THREE.MeshStandardMaterial
    ['character_3_export-2 #219']: THREE.MeshStandardMaterial
  }
}

type ActionName =
  | 'headAction'
  | 'bodyAction'
  | 'right_legAction'
  | 'left_legAction'
  | 'right_handAction'
  | 'left_handAction'
type GLTFActions = Record<ActionName, THREE.AnimationAction>

export default function Character({ position, ...props }) {
  const chracRef = useRef<MeshProps>()

  const { nodes, materials, animations } = useGLTF(
    'models/player.glb'
  ) as GLTFResult

  var lastCalledTime
  var counter = 0
  var fpsArray = []

  useFrame(
    ({ scene, camera, mouse, get, clock, performance, frameloop }, delta) => {
      var fps
      let avgFPS

      if (!lastCalledTime) {
        lastCalledTime = new Date().getTime()
        fps = 0
      }

      var delta = (new Date().getTime() - lastCalledTime) / 1000
      lastCalledTime = new Date().getTime()
      fps = Math.ceil(1 / delta)

      if (counter >= 60) {
        var sum = fpsArray.reduce(function (a, b) {
          return a + b
        })
        var average = Math.ceil(sum / fpsArray.length)
        // console.log(average)
        avgFPS = average
        counter = 0
      } else {
        if (fps !== Infinity) {
          fpsArray.push(fps)
        }

        counter++
      }

      const { x, y } = mouse
      const mouseDegree = Math.atan2(y, x)

      const { canMove, moveForward, currentChunk } = useCharacter.getState()
      const chunkI = chunkIndex(currentChunk)
      const chunk = chunksData[chunkI[0]][chunkI[1]]
      const { cameraOffset, mouseDegreeOffset } = chunk
        ? chunk
        : {
            cameraOffset: [50, 50, 50],
            mouseDegreeOffset: -0.7,
          }

      if (chracRef.current) {
        chracRef.current.rotation.set(0, mouseDegree + mouseDegreeOffset, 0) // -1

        // console.log(canMove)

        // console.log(chracRef.current.position)

        if (moveForward && canMove) {
          // if (collidesData.length > 0) return

          const counterFPS = 120 / fps

          // setMouseDegree(mouseDegree)
          chracRef.current.translateZ(-0.15 * counterFPS) // -0.15, -0.15 --- -0.13

          const [x, y, z] = cameraOffset

          const charNewPos = {
            x: x + chracRef.current.position.x,
            y: y + chracRef.current.position.y,
            z: z + chracRef.current.position.z,
          }

          // camera.position.set(charNewPos.x, charNewPos.y, charNewPos.z)
          // THREE.MathUtils.lerp(charNewPos, 100, 0.1)
          camera.position.lerp(charNewPos, 0.06)
        }

        // console.log(chracRef.current.position.y)
      }
    }
  )

  const onMouseDown = (e) => {
    e.preventDefault()

    // console.log('mouse down')

    if (!useCharacter.getState().moveForward) {
      detectLeftButtonBtn(e) && useCharacter.getState().setMoveForward(true)
      // invalidate()
    }
  }

  const onMouseUp = (e) => {
    e.preventDefault()

    if (useCharacter.getState().moveForward) {
      useCharacter.getState().setMoveForward(false)
    }
  }

  useEffect(() => {
    console.log('character rerender')

    window.addEventListener('mousedown', onMouseDown)
    window.addEventListener('mouseup', onMouseUp)

    window.addEventListener('pointerdown', onMouseDown)
    window.addEventListener('pointerup', onMouseUp)

    return () => {
      window.removeEventListener('mousedown', onMouseDown)
      window.removeEventListener('mouseup', onMouseUp)

      window.removeEventListener('pointerdown', onMouseDown)
      window.removeEventListener('pointerup', onMouseUp)
    }
  }, [])

  return (
    <>
      <group
        ref={chracRef}
        {...props}
        name='character'
        userData={{ id: 'character' }}
        dispose={null}
        scale={0.3}
        position={position}
      >
        <PlayerName />
        <group position={[0, 16.37, 0]}>
          <mesh
            geometry={nodes.Cube.geometry}
            material={nodes.Cube.material}
            // position={[-13.66, 15.26, -0.08]}
            position={[5, 0, 0]}
            scale={[1.54, 5.57, 1.93]}
          />
        </group>
      </group>
    </>
  )
}

// // useGLTF.preload('/character.glb')
